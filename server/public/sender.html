<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebRTC Screen Share - Sender</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .control-panel {
            margin-bottom: 20px;
        }
        .status {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .log {
            height: 200px;
            overflow-y: auto;
            background: #000;
            color: #00ff00;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 14px;
        }
        #mouse {
            width: 20px;
            height: 20px;
            background: #dd2525;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 100px;
        }
        #meta2d {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<div id="mouse"></div>
<h2>ğŸ“¹ Sender (Screen Share with Mouse Control)</h2>

<div class="control-panel">
    <button id="startBtn">å¼€å§‹å…±äº«å±å¹•</button>
    <button id="stopBtn" disabled>åœæ­¢å…±äº«</button>
</div>

<div class="status">
    <div>è¿æ¥çŠ¶æ€: <span id="connectionStatus">æœªè¿æ¥</span></div>
    <div>å…±äº«çŠ¶æ€: <span id="shareStatus">æœªå¼€å§‹</span></div>
    <div>é¼ æ ‡æ§åˆ¶: <span id="mouseStatus">æœªæ¿€æ´»</span></div>
</div>

<div class="log" id="logArea" onclick="alert(1)"></div>
<div id="meta2d"></div>
<script src="https://cdn.jsdelivr.net/npm/meta2d.js@1.0.95-alpha.1/meta2d.min.js"></script>
<script>
    const contan = document.querySelector('#meta2d');
    const meta2d = new Meta2d(contan);
    fetch('./1.json').then(res => res.json()).then(data => {
        meta2d.open(data)
    })
</script>
<script>
    const ws = new WebSocket("wss://192.168.0.20:443");
    const pc = new RTCPeerConnection();
    const dataChannel = pc.createDataChannel("mouseControl");

    let stream;
    let isSharing = false;
    let mouseControlEnabled = false;

    const statusElements = {
        connection: document.getElementById('connectionStatus'),
        share: document.getElementById('shareStatus'),
        mouse: document.getElementById('mouseStatus')
    };

    const logArea = document.getElementById('logArea');

    // æ—¥å¿—è®°å½•å‡½æ•°
    function log(message) {
        const timestamp = new Date().toLocaleTimeString();
        logArea.textContent += `[${timestamp}] ${message}\n`;
        logArea.scrollTop = logArea.scrollHeight;
        console.log(message);
    }

    // WebSocket è¿æ¥äº‹ä»¶
    ws.onopen = () => {
        statusElements.connection.textContent = 'å·²è¿æ¥';
        statusElements.connection.style.color = 'green';
        log('WebSocket è¿æ¥å·²å»ºç«‹');
    };

    ws.onclose = () => {
        statusElements.connection.textContent = 'å·²æ–­å¼€';
        statusElements.connection.style.color = 'red';
        log('WebSocket è¿æ¥å·²æ–­å¼€');
    };

    ws.onerror = (error) => {
        log('WebSocket é”™è¯¯: ' + error);
    };

    // RTCPeerConnection äº‹ä»¶
    pc.onconnectionstatechange = () => {
        log(`PeerConnection çŠ¶æ€: ${pc.connectionState}`);
    };

    pc.oniceconnectionstatechange = () => {
        log(`ICE è¿æ¥çŠ¶æ€: ${pc.iceConnectionState}`);
    };

    // å‘é€ ICE å€™é€‰
    pc.onicecandidate = (event) => {
        if (event.candidate) {
            ws.send(JSON.stringify({
                type: "candidate",
                candidate: event.candidate
            }));
            log('å‘é€ ICE å€™é€‰');
        }
    };

    // DataChannel äº‹ä»¶å¤„ç†
    dataChannel.onopen = () => {
        log('æ•°æ®é€šé“å·²æ‰“å¼€ - é¼ æ ‡æ§åˆ¶æ¿€æ´»');
        mouseControlEnabled = true;
        statusElements.mouse.textContent = 'å·²æ¿€æ´»';
        statusElements.mouse.style.color = 'green';
    };

    dataChannel.onclose = () => {
        log('æ•°æ®é€šé“å·²å…³é—­ - é¼ æ ‡æ§åˆ¶åœç”¨');
        mouseControlEnabled = false;
        statusElements.mouse.textContent = 'æœªæ¿€æ´»';
        statusElements.mouse.style.color = 'red';
    };

    dataChannel.onerror = (error) => {
        log('æ•°æ®é€šé“é”™è¯¯: ' + error);
    };

    // æ¥æ”¶æ¥è‡ªè¿œç«¯çš„é¼ æ ‡æ§åˆ¶å‘½ä»¤
    dataChannel.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            handleRemoteMouseEvent(data);
        } catch (e) {
            log('è§£æé¼ æ ‡æ§åˆ¶æ•°æ®å¤±è´¥: ' + e);
        }
    };


    // å¤„ç†è¿œç¨‹é¼ æ ‡äº‹ä»¶
    function handleRemoteMouseEvent(data) {
        // log(`æ”¶åˆ°é¼ æ ‡äº‹ä»¶: ${data.type} (${data.x}, ${data.y})`);

        const {x,y,button} = data;
        simulateMouseMove(x, y);
        const mouseEvent = new MouseEvent(data.type, {
            view: window,
            bubbles: true,
            cancelable: true,
            clientX: x,
            clientY: y,
            button: button
        });

        // åœ¨ç›®æ ‡å…ƒç´ ä¸Šè§¦å‘ç‚¹å‡»ï¼ˆæˆ–ç›´æ¥ dispatch åˆ° documentï¼‰
        const target = document.elementFromPoint(x, y) || document.body;
        console.log(data.type,target)

        target.dispatchEvent(mouseEvent);
        // switch(data.type) {
        //     case 'mousemove':
        //         // æ¨¡æ‹Ÿé¼ æ ‡ç§»åŠ¨
        //         const {x,y,button} = data;
        //         simulateMouseMove(x, y);
        //         const mouseEvent = new MouseEvent('mousemove', {
        //             view: window,
        //             bubbles: true,
        //             cancelable: true,
        //             clientX: x,
        //             clientY: y,
        //             button: button
        //         });
        //
        //         // åœ¨ç›®æ ‡å…ƒç´ ä¸Šè§¦å‘ç‚¹å‡»ï¼ˆæˆ–ç›´æ¥ dispatch åˆ° documentï¼‰
        //         const target = document.elementFromPoint(x, y) || document.body;
        //         target.dispatchEvent(mouseEvent);
        //         break;
        //     case 'mousedown':
        //         // æ¨¡æ‹Ÿé¼ æ ‡æŒ‰ä¸‹
        //         simulateMouseDown(data.x, data.y, data.button);
        //         break;
        //     case 'mouseup':
        //         // æ¨¡æ‹Ÿé¼ æ ‡æ¾å¼€
        //         simulateMouseUp(data.x, data.y, data.button);
        //         break;
        //     case 'click':
        //         // æ¨¡æ‹Ÿé¼ æ ‡ç‚¹å‡»
        //         simulateMouseClick(data.x, data.y, data.button);
        //         break;
        //     case 'wheel':
        //         // æ¨¡æ‹Ÿé¼ æ ‡æ»šè½®
        //         simulateMouseWheel(data.x, data.y, data.deltaX, data.deltaY);
        //         break;
        // }
    }

    // é¼ æ ‡äº‹ä»¶æ¨¡æ‹Ÿå‡½æ•°ï¼ˆæµè§ˆå™¨ç¯å¢ƒä¸‹çš„æ›¿ä»£æ–¹æ¡ˆï¼‰
    function simulateMouseMove(x, y) {
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œéœ€è¦è°ƒç”¨ç³»ç»ŸAPI
        const mouse = document.getElementById('mouse');
        mouse.style.left = x + 'px';
        mouse.style.top = y + 'px';
    }

    function simulateMouseDown(x, y, button) {
        log(`æ¨¡æ‹Ÿé¼ æ ‡æŒ‰ä¸‹: (${x}, ${y}) æŒ‰é’®: ${button}`);
    }

    function simulateMouseUp(x, y, button) {
        log(`æ¨¡æ‹Ÿé¼ æ ‡æ¾å¼€: (${x}, ${y}) æŒ‰é’®: ${button}`);
    }

    function simulateMouseClick(x, y, button) {
        log(`æ¨¡æ‹Ÿé¼ æ ‡ç‚¹å‡»: (${x}, ${y}) æŒ‰é’®: ${button}`);
    }

    function simulateMouseWheel(x, y, deltaX, deltaY) {
        log(`æ¨¡æ‹Ÿé¼ æ ‡æ»šè½®: (${x}, ${y}) æ»šåŠ¨: (${deltaX}, ${deltaY})`);
    }

    // é”®ç›˜äº‹ä»¶å¤„ç†ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
    function handleKeyboardEvent(data) {
        log(`æ”¶åˆ°é”®ç›˜äº‹ä»¶: ${data.type} é”®: ${data.key}`);
        // æ¨¡æ‹Ÿé”®ç›˜äº‹ä»¶
    }

    // æ¥æ”¶ä¿¡ä»¤
    ws.onmessage = async (msg) => {
        const _data = msg.data;
        let data;
        try {
            if (typeof _data === 'string') {
                data = JSON.parse(_data);
            } else if (_data instanceof Blob) {
                const text = await new Promise(r => {
                    const reader = new FileReader();
                    reader.onload = () => r(reader.result);
                    reader.readAsText(_data);
                });
                data = JSON.parse(text);
            } else {
                return;
            }
        } catch (e) {
            log("è§£ææ¶ˆæ¯å¤±è´¥: " + e);
            return;
        }

        if (data.type === "answer") {
            await pc.setRemoteDescription(new RTCSessionDescription({
                type: data.type,
                sdp: data.sdp
            }));
            log('æ¥æ”¶åˆ° Answerï¼Œè®¾ç½®è¿œç¨‹æè¿°');
        } else if (data.type === "candidate") {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                log('æ·»åŠ  ICE å€™é€‰æˆåŠŸ');
            } catch(e) {
                log("æ·»åŠ  ICE å€™é€‰å¤±è´¥: " + e);
            }
        }
    };

    // å¼€å§‹å±å¹•å…±äº«
    document.getElementById("startBtn").onclick = async () => {
        try {
            const constraints = {
                video: { // 4k
                    width: { max: 4096 },
                    height: { max: 2460 },
                    frameRate: { max: 50 }
                },
                audio: false
            };

            stream = await navigator.mediaDevices.getDisplayMedia(constraints);

            // æ·»åŠ æ‰€æœ‰ track
            stream.getTracks().forEach(track => pc.addTrack(track, stream));

            // ç›‘å¬æµç»“æŸäº‹ä»¶
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                log('å±å¹•å…±äº«å·²åœæ­¢');
                stopSharing();
            });

            // åˆ›å»º offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            // å‘é€ offer
            ws.send(JSON.stringify({
                type: offer.type,
                sdp: offer.sdp
            }));

            isSharing = true;
            statusElements.share.textContent = 'å…±äº«ä¸­';
            statusElements.share.style.color = 'green';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            log('å¼€å§‹å±å¹•å…±äº«ï¼Œå‘é€ Offer');

        } catch (err) {
            log("å±å¹•å…±äº«å¤±è´¥: " + err);
        }
    };

    // åœæ­¢å±å¹•å…±äº«
    document.getElementById("stopBtn").onclick = stopSharing;

    function stopSharing() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }

        if (pc) {
            pc.close();
        }

        isSharing = false;
        mouseControlEnabled = false;
        statusElements.share.textContent = 'å·²åœæ­¢';
        statusElements.share.style.color = 'red';
        statusElements.mouse.textContent = 'æœªæ¿€æ´»';
        statusElements.mouse.style.color = 'red';
        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;

        log('å±å¹•å…±äº«å·²åœæ­¢');
    }

    // å‘é€å¿ƒè·³ä¿æŒè¿æ¥
    setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'ping' }));
        }
    }, 30000);

</script>

</body>
</html>